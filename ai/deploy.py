# ai/deploy.py
# GitHub deployment helper
# - Creates a repository and pushes generated files
# - Configures GitHub Pages to serve the site
# Uses direct GitHub REST API via requests to avoid heavy dependencies.
# Expects GITHUB_TOKEN in the environment.
#
# (No changes needed for this update)

import os
import base64
import json
import requests
from typing import Dict, Any

GITHUB_API = "https://api.github.com"


class GitHubDeployer:
    def __init__(self, token: str = None):
        self.token = token or os.environ.get("GITHUB_TOKEN")
        if not self.token:
            # We'll allow instance but operations will fail with helpful error
            pass
        self.headers = {"Authorization": f"token {self.token}", "Accept": "application/vnd.github.v3+json"}

    def deploy_to_github_pages(self, repo_name: str, files: Dict[str, str], make_public: bool = True) -> Dict[str, Any]:
        """
        Creates a repository under the authenticated user, commits files to the main branch,
        and enables GitHub Pages serving from the main branch root.
        Returns a dict with status and site URL if available.
        """
        if not self.token:
            raise RuntimeError("GITHUB_TOKEN not set. Deployment needs a GitHub Personal Access Token.")

        user = self._get_authenticated_user()
        if not user:
            raise RuntimeError("Could not get authenticated GitHub user. Check GITHUB_TOKEN.")
        owner = user["login"]

        # 1) Create repo
        repo = self._create_repo(owner, repo_name, private=(not make_public))
        full_name = repo.get("full_name")
        if not full_name:
            raise RuntimeError("Failed to create repo: " + json.dumps(repo))

        # 2) Create a commit with the files on main branch
        self._create_files_commit(owner, repo_name, files)

        # 3) Enable Pages (set source to main)
        pages_resp = self._enable_github_pages(owner, repo_name)

        # Try to find pages URL (may take a few seconds to build)
        pages_info = pages_resp
        url = pages_info.get("html_url") or f"https://{owner}.github.io/{repo_name}"
        return {"repo": full_name, "url": url, "pages_info": pages_info}

    # -------------------------
    # Low-level helpers
    # -------------------------
    def _get_authenticated_user(self):
        resp = requests.get(f"{GITHUB_API}/user", headers=self.headers)
        if resp.status_code != 200:
            return None
        return resp.json()

    def _create_repo(self, owner: str, repo_name: str, private: bool = False):
        url = f"{GITHUB_API}/user/repos"
        payload = {"name": repo_name, "private": private, "auto_init": False,
                   "description": "Generated by AI Website Builder"}
        resp = requests.post(url, headers=self.headers, json=payload)
        if resp.status_code not in (200, 201):
            # If repo already exists, attempt to use it
            if resp.status_code == 422:
                resp2 = requests.get(f"{GITHUB_API}/repos/{owner}/{repo_name}", headers=self.headers)
                if resp2.status_code == 200:
                    return resp2.json()
            raise RuntimeError(f"Failed to create repo: {resp.status_code} {resp.text}")
        return resp.json()

    def _create_files_commit(self, owner: str, repo: str, files: Dict[str, str]):
        """
        Creates an initial commit by creating/updating files via PUT /repos/:owner/:repo/contents/:path
        This is simpler than the full git data API for this app's use case.
        """
        for path, content in files.items():
            url = f"{GITHUB_API}/repos/{owner}/{repo}/contents/{path}"

            # Ensure content is utf-8 encoded for b64
            content_bytes = content.encode("utf-8") if isinstance(content, str) else content

            payload = {
                "message": f"Add/Update {path} (AI Website Builder)",
                "content": base64.b64encode(content_bytes).decode("utf-8")
            }

            # Check if file exists to get its SHA (for updates)
            try:
                get_resp = requests.get(url, headers=self.headers)
                if get_resp.status_code == 200:
                    payload["sha"] = get_resp.json().get("sha")
            except Exception:
                pass  # File doesn't exist, proceed with create

            # Create or update the file
            resp = requests.put(url, headers=self.headers, json=payload)
            if resp.status_code not in (200, 201):
                raise RuntimeError(f"Failed to create/update file {path}: {resp.status_code} {resp.text}")

    def _enable_github_pages(self, owner: str, repo: str):
        """
        Configure Pages to deploy from main branch root.
        """
        url = f"{GITHUB_API}/repos/{owner}/{repo}/pages"
        payload = {"source": {"branch": "main", "path": "/"}}
        # Use new 'actions' build type if available, fallback to 'legacy'
        payload["build_type"] = "workflow"

        resp = requests.post(url, headers=self.headers, json=payload)

        if resp.status_code == 201:  # Created
            return resp.json()

        # If it fails (e.g., 422), try legacy build type
        payload["build_type"] = "legacy"
        resp_legacy = requests.post(url, headers=self.headers, json=payload)

        if resp_legacy.status_code in (201, 204, 200):
            return resp_legacy.json() if resp_legacy.content else {}
        elif resp_legacy.status_code == 422:
            # Already set; get the pages info
            resp_get = requests.get(url, headers=self.headers)
            if resp_get.status_code == 200:
                return resp_get.json()

        # fallback: craft a likely URL
        return {"html_url": f"https://{owner}.github.io/{repo}"}